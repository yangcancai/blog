<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/blog/2020/06/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>mysql的select count(*) count(1) count(Id)区别</title>
    <url>/blog/2020/06/11/select-count/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>select</tag>
      </tags>
  </entry>
  <entry>
    <title>dead_lock</title>
    <url>/blog/2020/06/18/dead-lock/</url>
    <content><![CDATA[<p> 大家都知道写程序不小心很容易造成死锁，死锁的结果就是程序卡死了。如果在线上出现这种情况该如何处理尼。这篇文章会模拟死锁的情况使用工具进行问题定位，基本算是一篇入门的文章，各路大神可以忽略。</p>
<h3 id="linux-c-死锁调试"><a href="#linux-c-死锁调试" class="headerlink" title="linux c++死锁调试"></a>linux c++死锁调试</h3><h4 id="AB-BA型的c-代码"><a href="#AB-BA型的c-代码" class="headerlink" title="AB-BA型的c++代码"></a>AB-BA型的c++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">thread_str</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rs;</span><br><span class="line">&#125;thread_str;</span><br><span class="line"><span class="keyword">int</span> g_tickets = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> g_num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> g_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> g_mutex_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sell_num</span><span class="params">(<span class="keyword">int</span> thread)</span></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;g_mutex_num);</span><br><span class="line">    <span class="keyword">if</span> (g_num &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread%d sell num:%d\n"</span>, thread, g_num--);</span><br><span class="line">    pthread_mutex_unlock(&amp;g_mutex_num);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_proc1</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>* pthread = <span class="keyword">static_cast</span>&lt;thread_str*&gt;(arg);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;g_mutex);</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        sell_num(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (g_tickets &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread 1 sell tickets:%d\n"</span>, g_tickets--);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;g_mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread-&gt;rs = <span class="number">1</span>;</span><br><span class="line">    pthread_exit(pthread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_proc2</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>* pthread = <span class="keyword">static_cast</span>&lt;thread_str*&gt;(arg);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;g_mutex_num);</span><br><span class="line">        pthread_mutex_lock(&amp;g_mutex);</span><br><span class="line">        <span class="keyword">if</span> (g_tickets &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread 2 sell tickets:%d\n"</span>, g_tickets--);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;g_mutex);</span><br><span class="line">            <span class="keyword">if</span> (g_num &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"thread%d sell num:%d\n"</span>, <span class="number">2</span>, g_num--);</span><br><span class="line">            pthread_mutex_unlock(&amp;g_mutex_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_mutex);</span><br><span class="line">        <span class="keyword">if</span> (g_num &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread%d sell num:%d\n"</span>, <span class="number">2</span>, g_num--);</span><br><span class="line">        pthread_mutex_unlock(&amp;g_mutex_num);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread-&gt;rs = <span class="number">2</span>;</span><br><span class="line">    pthread_exit(pthread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">void</span> *ret1, *ret2;</span><br><span class="line">    thread_str t1,t2;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_proc1, &amp;t1);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread_proc2, &amp;t2);</span><br><span class="line">    pthread_join(tid1, &amp;ret1);</span><br><span class="line">    pthread_join(tid2, &amp;ret2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ret1:%d\n"</span>, <span class="keyword">static_cast</span>&lt;thread_str*&gt;(ret1)-&gt;rs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ret2:%d\n"</span>, <span class="keyword">static_cast</span>&lt;thread_str*&gt;(ret2)-&gt;rs);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法一gdb"><a href="#方法一gdb" class="headerlink" title="方法一gdb"></a>方法一gdb</h4><h5 id="1、启动程序-build-sh"><a href="#1、启动程序-build-sh" class="headerlink" title="1、启动程序./build.sh"></a>1、启动程序./build.sh</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[cam@localhost demo_cpp]$ ./build.sh </span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /data/c++/demo_cpp/cmake-build-debug</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/debug_dead_lock.dir/debug_dead_lock.cpp.o</span><br><span class="line">[100%] Linking CXX executable debug_dead_lock</span><br><span class="line">[100%] Built target debug_dead_lock</span><br><span class="line">thread 2 sell tickets:100</span><br><span class="line">thread2 sell num:100</span><br><span class="line">thread 2 sell tickets:99</span><br><span class="line">thread2 sell num:99</span><br><span class="line">thread 2 sell tickets:98</span><br><span class="line">thread2 sell num:98</span><br><span class="line">.....................</span><br><span class="line">.....................</span><br><span class="line">thread2 sell num:45</span><br><span class="line">thread 2 sell tickets:44</span><br><span class="line">thread2 sell num:44</span><br><span class="line">thread 2 sell tickets:43</span><br><span class="line">thread2 sell num:43</span><br></pre></td></tr></table></figure>
<h5 id="2、查看进程的pid-ps-ef-grep-debug"><a href="#2、查看进程的pid-ps-ef-grep-debug" class="headerlink" title="2、查看进程的pid ps -ef | grep debug"></a>2、查看进程的pid ps -ef | grep debug</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[cam@localhost ~]$ ps -ef | grep debug</span><br><span class="line">cam      29815 29788  0 04:30 pts/0    00:00:00 ./debug_dead_lock</span><br></pre></td></tr></table></figure>
<h5 id="3、查看当前进程所有的线程"><a href="#3、查看当前进程所有的线程" class="headerlink" title="3、查看当前进程所有的线程"></a>3、查看当前进程所有的线程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[cam@localhost ~]$ pstree -p 29815</span><br><span class="line">debug_dead_lock(29815)─┬─&#123;debug_dead_loc&#125;(29816)</span><br><span class="line">                       └─&#123;debug_dead_loc&#125;(29817)</span><br></pre></td></tr></table></figure>
<p>该进程包括一个main线程和2个子线程，跟代码表现是一样的</p>
<h5 id="4、启动gdb，attach到该进程，打印所有的线程栈"><a href="#4、启动gdb，attach到该进程，打印所有的线程栈" class="headerlink" title="4、启动gdb，attach到该进程，打印所有的线程栈"></a>4、启动gdb，attach到该进程，打印所有的线程栈</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[cam@localhost ~]$ sudo gdb</span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux 8.2-3.el6</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">"show copying"</span> and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-redhat-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>.</span><br><span class="line">(gdb) attach 29815</span><br><span class="line">Attaching to process 29815</span><br><span class="line">[New LWP 29816]</span><br><span class="line">[New LWP 29817]</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">"/lib64/libthread_db.so.1"</span>.</span><br><span class="line">0x00007f782442c2fd <span class="keyword">in</span> pthread_join () from /lib64/libpthread.so.0</span><br><span class="line">(gdb) thread apply all bt</span><br><span class="line"></span><br><span class="line">Thread 3 (Thread 0x7f78230ee700 (LWP 29817)):</span><br><span class="line"><span class="comment">#0  0x00007f7824432334 in __lll_lock_wait () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#1  0x00007f782442d5d8 in _L_lock_854 () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#2  0x00007f782442d4a7 in pthread_mutex_lock () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#3  0x00000000004009c6 in thread_proc2 (arg=0x7ffc09b61b08) at /data/c++/demo_cpp/debug_dead_lock.cpp:52</span></span><br><span class="line"><span class="comment">#4  0x00007f782442baa1 in start_thread () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#5  0x00007f78239d8c4d in clone () from /lib64/libc.so.6</span></span><br><span class="line"></span><br><span class="line">Thread 2 (Thread 0x7f78238ef700 (LWP 29816)):</span><br><span class="line"><span class="comment">#0  0x00007f7824432334 in __lll_lock_wait () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#1  0x00007f782442d5d8 in _L_lock_854 () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#2  0x00007f782442d4a7 in pthread_mutex_lock () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#3  0x00000000004008d7 in sell_num (thread=1) at /data/c++/demo_cpp/debug_dead_lock.cpp:19</span></span><br><span class="line"><span class="comment">#4  0x0000000000400945 in thread_proc1 (arg=0x7ffc09b61b0c) at /data/c++/demo_cpp/debug_dead_lock.cpp:32</span></span><br><span class="line"><span class="comment">#5  0x00007f782442baa1 in start_thread () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#6  0x00007f78239d8c4d in clone () from /lib64/libc.so.6</span></span><br><span class="line"></span><br><span class="line">Thread 1 (Thread 0x7f7824854720 (LWP 29815)):</span><br><span class="line"><span class="comment">#0  0x00007f782442c2fd in pthread_join () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#1  0x0000000000400af4 in main (argc=1, argv=0x7ffc09b61c18) at /data/c++/demo_cpp/debug_dead_lock.cpp:80</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>总结：Thread1和Thread2当前线程都执行到__lll_lock_wait这个函数，再查看对应debug_dead_lock.cpp:19和debug_dead_lock.cpp:32,<br>对应的代码都是等待锁，这里是两个锁，1线程等待2线程获取的锁，2线程等待1线程获取的锁，就造成了dead_lock</p>
<h4 id="方法二valgrind-helgrind"><a href="#方法二valgrind-helgrind" class="headerlink" title="方法二valgrind(helgrind)"></a>方法二valgrind(helgrind)</h4><h5 id="1、命令-valgrind-–tool-helgrind-cmake-build-debug-debug-dead-lock"><a href="#1、命令-valgrind-–tool-helgrind-cmake-build-debug-debug-dead-lock" class="headerlink" title="1、命令:valgrind –tool=helgrind cmake-build-debug/debug_dead_lock"></a>1、命令:valgrind –tool=helgrind cmake-build-debug/debug_dead_lock</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[cam@localhost demo_cpp]$ valgrind --tool=helgrind cmake-build-debug/debug_dead_lock </span><br><span class="line">==29920== Helgrind, a thread error detector</span><br><span class="line">==29920== Copyright (C) 2007-2017, and GNU GPL<span class="string">'d, by OpenWorks LLP et al.</span></span><br><span class="line"><span class="string">==29920== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==29920== Command: cmake-build-debug/debug_dead_lock</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">thread1 sell num:100</span></span><br><span class="line"><span class="string">thread 1 sell tickets:100</span></span><br><span class="line"><span class="string">==29920== ---Thread-Announcement------------------------------------------</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== Thread #3 was created</span></span><br><span class="line"><span class="string">==29920==    at 0x58DEC0E: clone (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E3F90F: do_clone.clone.0 (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E3FE6C: pthread_create@@GLIBC_2.2.5 (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C34320: pthread_create_WRK (hg_intercepts.c:427)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C344A5: pthread_create@* (hg_intercepts.c:460)</span></span><br><span class="line"><span class="string">==29920==    by 0x400AE0: main (debug_dead_lock.cpp:79)</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== ----------------------------------------------------------------</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== Thread #3: lock order "0x6020C0 before 0x602100" violated</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== Observed (incorrect) order is: acquisition of lock at 0x602100</span></span><br><span class="line"><span class="string">==29920==    at 0x4C320C5: mutex_lock_WRK (hg_intercepts.c:909)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C32150: pthread_mutex_lock (hg_intercepts.c:925)</span></span><br><span class="line"><span class="string">==29920==    by 0x4009BB: thread_proc2(void*) (debug_dead_lock.cpp:51)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C3452E: mythread_wrapper (hg_intercepts.c:389)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E40AA0: start_thread (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x58DEC4C: clone (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920==  followed by a later acquisition of lock at 0x6020C0</span></span><br><span class="line"><span class="string">==29920==    at 0x4C320C5: mutex_lock_WRK (hg_intercepts.c:909)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C32150: pthread_mutex_lock (hg_intercepts.c:925)</span></span><br><span class="line"><span class="string">==29920==    by 0x4009C5: thread_proc2(void*) (debug_dead_lock.cpp:52)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C3452E: mythread_wrapper (hg_intercepts.c:389)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E40AA0: start_thread (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x58DEC4C: clone (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== Required order was established by acquisition of lock at 0x6020C0</span></span><br><span class="line"><span class="string">==29920==    at 0x4C320C5: mutex_lock_WRK (hg_intercepts.c:909)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C32150: pthread_mutex_lock (hg_intercepts.c:925)</span></span><br><span class="line"><span class="string">==29920==    by 0x400930: thread_proc1(void*) (debug_dead_lock.cpp:30)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C3452E: mythread_wrapper (hg_intercepts.c:389)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E40AA0: start_thread (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x58DEC4C: clone (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920==  followed by a later acquisition of lock at 0x602100</span></span><br><span class="line"><span class="string">==29920==    at 0x4C320C5: mutex_lock_WRK (hg_intercepts.c:909)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C32150: pthread_mutex_lock (hg_intercepts.c:925)</span></span><br><span class="line"><span class="string">==29920==    by 0x4008D6: sell_num(int) (debug_dead_lock.cpp:19)</span></span><br><span class="line"><span class="string">==29920==    by 0x400944: thread_proc1(void*) (debug_dead_lock.cpp:32)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C3452E: mythread_wrapper (hg_intercepts.c:389)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E40AA0: start_thread (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x58DEC4C: clone (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920==  Lock at 0x6020C0 was first observed</span></span><br><span class="line"><span class="string">==29920==    at 0x4C320C5: mutex_lock_WRK (hg_intercepts.c:909)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C32150: pthread_mutex_lock (hg_intercepts.c:925)</span></span><br><span class="line"><span class="string">==29920==    by 0x400930: thread_proc1(void*) (debug_dead_lock.cpp:30)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C3452E: mythread_wrapper (hg_intercepts.c:389)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E40AA0: start_thread (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x58DEC4C: clone (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==29920==  Address 0x6020c0 is 0 bytes inside data symbol "g_mutex"</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920==  Lock at 0x602100 was first observed</span></span><br><span class="line"><span class="string">==29920==    at 0x4C320C5: mutex_lock_WRK (hg_intercepts.c:909)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C32150: pthread_mutex_lock (hg_intercepts.c:925)</span></span><br><span class="line"><span class="string">==29920==    by 0x4008D6: sell_num(int) (debug_dead_lock.cpp:19)</span></span><br><span class="line"><span class="string">==29920==    by 0x400944: thread_proc1(void*) (debug_dead_lock.cpp:32)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C3452E: mythread_wrapper (hg_intercepts.c:389)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E40AA0: start_thread (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x58DEC4C: clone (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==29920==  Address 0x602100 is 0 bytes inside data symbol "g_mutex_num"</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">thread 2 sell tickets:99</span></span><br><span class="line"><span class="string">thread2 sell num:99</span></span><br><span class="line"><span class="string">thread 2 sell tickets:98</span></span><br><span class="line"><span class="string">thread2 sell num:98</span></span><br><span class="line"><span class="string">thread 2 sell tickets:97</span></span><br><span class="line"><span class="string">thread2 sell num:97</span></span><br><span class="line"><span class="string">thread 2 sell tickets:96</span></span><br><span class="line"><span class="string">thread2 sell num:96</span></span><br><span class="line"><span class="string">thread 2 sell tickets:95</span></span><br><span class="line"><span class="string">thread2 sell num:95</span></span><br><span class="line"><span class="string">thread 2 sell tickets:94</span></span><br><span class="line"><span class="string">thread2 sell num:94</span></span><br><span class="line"><span class="string">thread 2 sell tickets:93</span></span><br><span class="line"><span class="string">thread2 sell num:93</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">^C==29920== </span></span><br><span class="line"><span class="string">==29920== Process terminating with default action of signal 2 (SIGINT)</span></span><br><span class="line"><span class="string">==29920==    at 0x4E412FD: pthread_join (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C325CA: pthread_join_WRK (hg_intercepts.c:553)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C326A5: pthread_join (hg_intercepts.c:572)</span></span><br><span class="line"><span class="string">==29920==    by 0x400AF3: main (debug_dead_lock.cpp:80)</span></span><br><span class="line"><span class="string">==29920== ----------------------------------------------------------------</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== Thread #3: Exiting thread still holds 1 lock</span></span><br><span class="line"><span class="string">==29920==    at 0x4E47334: __lll_lock_wait (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E425D7: _L_lock_854 (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E424A5: pthread_mutex_lock (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C32065: mutex_lock_WRK (hg_intercepts.c:902)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C32150: pthread_mutex_lock (hg_intercepts.c:925)</span></span><br><span class="line"><span class="string">==29920==    by 0x4009C5: thread_proc2(void*) (debug_dead_lock.cpp:52)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C3452E: mythread_wrapper (hg_intercepts.c:389)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E40AA0: start_thread (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x58DEC4C: clone (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== ---Thread-Announcement------------------------------------------</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== Thread #2 was created</span></span><br><span class="line"><span class="string">==29920==    at 0x58DEC0E: clone (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E3F90F: do_clone.clone.0 (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E3FE6C: pthread_create@@GLIBC_2.2.5 (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C34320: pthread_create_WRK (hg_intercepts.c:427)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C344A5: pthread_create@* (hg_intercepts.c:460)</span></span><br><span class="line"><span class="string">==29920==    by 0x400AC3: main (debug_dead_lock.cpp:78)</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== ----------------------------------------------------------------</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== Thread #2: Exiting thread still holds 1 lock</span></span><br><span class="line"><span class="string">==29920==    at 0x4E47334: __lll_lock_wait (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E425D7: _L_lock_854 (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E424A5: pthread_mutex_lock (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C32065: mutex_lock_WRK (hg_intercepts.c:902)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C32150: pthread_mutex_lock (hg_intercepts.c:925)</span></span><br><span class="line"><span class="string">==29920==    by 0x4008D6: sell_num(int) (debug_dead_lock.cpp:19)</span></span><br><span class="line"><span class="string">==29920==    by 0x400944: thread_proc1(void*) (debug_dead_lock.cpp:32)</span></span><br><span class="line"><span class="string">==29920==    by 0x4C3452E: mythread_wrapper (hg_intercepts.c:389)</span></span><br><span class="line"><span class="string">==29920==    by 0x4E40AA0: start_thread (in /lib64/libpthread-2.12.so)</span></span><br><span class="line"><span class="string">==29920==    by 0x58DEC4C: clone (in /lib64/libc-2.12.so)</span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== </span></span><br><span class="line"><span class="string">==29920== For counts of detected and suppressed errors, rerun with: -v</span></span><br><span class="line"><span class="string">==29920== Use --history-level=approx or =none to gain increased speed, at</span></span><br><span class="line"><span class="string">==29920== the cost of reduced accuracy of conflicting-access information</span></span><br><span class="line"><span class="string">==29920== ERROR SUMMARY: 9 errors from 3 contexts (suppressed: 76 from 22)</span></span><br></pre></td></tr></table></figure>
<p>结论：通过Thread #2: Exiting thread still holds 1 lock,Thread #3: Exiting thread still holds 1 lock<br>可以知道这两个线程发生了AB-BA类型的死锁</p>
<h3 id="gdb和valgrind对比"><a href="#gdb和valgrind对比" class="headerlink" title="gdb和valgrind对比"></a>gdb和valgrind对比</h3><p> 1、gdb可以对启动的进程进行分析，不需要停止目标进程,所以对线死锁分析比较方便<br> 2、valgrind对于本地代码分析会更方便</p>
<h3 id="本实例代码"><a href="#本实例代码" class="headerlink" title="本实例代码"></a>本实例代码</h3><p><a href="https://github.com/yangcancai/demo_cpp/tree/c4ad603a47ad23e42e1861151aa225b0936b3996" target="_blank" rel="noopener">github demo_cpp</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>dead_lock</tag>
        <tag>gdb</tag>
        <tag>c++</tag>
        <tag>Valgrind</tag>
      </tags>
  </entry>
</search>
