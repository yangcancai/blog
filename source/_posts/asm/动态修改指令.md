## lldb核心代码
主要流程
1. 定位内存区域：
 使用 MachVMRegion::GetRegionForAddress 函数查找当前地址 curr_addr 所在的内存区域。这个函数通过调用 mach_vm_region_recurse 获取与指定地址相关的内存区域信息。
2. 检查和调整内存保护：
 一旦找到内存区域，代码会使用 MachVMRegion::SetProtections 函数将当前内存区域的保护属性设置为可读可写（VM_PROT_READ | VM_PROT_WRITE）。这个步骤确保了在写入数据之前，该内存区域具有写权限。
3. 写入数据：
 如果内存区域保护属性设置成功，代码会调用 WriteRegion 函数将数据写入内存区域。WriteRegion 会确保按页大小（或区域剩余大小）写入数据，并返回成功写入的字节数。
4. 更新进度：
 写入成功后，更新当前地址和数据指针，继续下一次写入，直到所有数据写入完成或者遇到错误。
5. 恢复之前的proction

```c++
nub_size_t MachVMMemory::Write(task_t task, nub_addr_t address,
                               const void *data, nub_size_t data_count) {
  MachVMRegion vmRegion(task);

  nub_size_t total_bytes_written = 0;
  nub_addr_t curr_addr = address;
  const uint8_t *curr_data = (const uint8_t *)data;

  while (total_bytes_written < data_count) {
    if (vmRegion.GetRegionForAddress(curr_addr)) {
      mach_vm_size_t curr_data_count = data_count - total_bytes_written;
      mach_vm_size_t region_bytes_left = vmRegion.BytesRemaining(curr_addr);
      if (region_bytes_left == 0) {
        break;
      }
      if (curr_data_count > region_bytes_left)
        curr_data_count = region_bytes_left;

      if (vmRegion.SetProtections(curr_addr, curr_data_count,
                                  VM_PROT_READ | VM_PROT_WRITE)) {
        nub_size_t bytes_written =
            WriteRegion(task, curr_addr, curr_data, curr_data_count);
        if (bytes_written <= 0) {
          // Status should have already be posted by WriteRegion...
          break;
        } else {
          total_bytes_written += bytes_written;
          curr_addr += bytes_written;
          curr_data += bytes_written;
        }
      } else {
        DNBLogThreadedIf(
            LOG_MEMORY_PROTECTIONS, "Failed to set read/write protections on "
                                    "region for address: [0x%8.8llx-0x%8.8llx)",
            (uint64_t)curr_addr, (uint64_t)(curr_addr + curr_data_count));
        break;
      }
    } else {
      DNBLogThreadedIf(LOG_MEMORY_PROTECTIONS,
                       "Failed to get region for address: 0x%8.8llx",
                       (uint64_t)address);
      break;
    }
  }

  return total_bytes_written;
}
```
## region类的一些关键字段
开始地址：m_start
大小：m_size
当前地址：m_addr
start_address = m_start
end_address = m_start + m_size
剩下字节： m_size - (m_addr-m_start)

## GetRegion
```c++
bool MachVMRegion::GetRegionForAddress(nub_addr_t addr) {
  // Restore any original protections and clear our vars
  Clear();
  m_err.Clear();
  m_addr = addr;
  m_start = addr;
  m_depth = 1024;
  mach_msg_type_number_t info_size = kRegionInfoSize;
  static_assert(sizeof(info_size) == 4);
  m_err =
      ::mach_vm_region_recurse(m_task, &m_start, &m_size, &m_depth,
                               (vm_region_recurse_info_t)&m_data, &info_size);

  const bool failed = m_err.Fail();
  const bool log_protections = DNBLogCheckLogBit(LOG_MEMORY_PROTECTIONS);

  if (log_protections || failed)
    m_err.LogThreaded("::mach_vm_region_recurse ( task = 0x%4.4x, address => "
                      "0x%8.8llx, size => %llu, nesting_depth => %d, info => "
                      "%p, infoCnt => %d) addr = 0x%8.8llx ",
                      m_task, (uint64_t)m_start, (uint64_t)m_size, m_depth,
                      &m_data, info_size, (uint64_t)addr);

  if (failed)
    return false;
  if (log_protections) {
    DNBLogThreaded("info = { prot = %u, "
                   "max_prot = %u, "
                   "inheritance = 0x%8.8x, "
                   "offset = 0x%8.8llx, "
                   "user_tag = 0x%8.8x, "
                   "ref_count = %u, "
                   "shadow_depth = %u, "
                   "ext_pager = %u, "
                   "share_mode = %u, "
                   "is_submap = %d, "
                   "behavior = %d, "
                   "object_id = 0x%8.8x, "
                   "user_wired_count = 0x%4.4x }",
                   m_data.protection, m_data.max_protection, m_data.inheritance,
                   (uint64_t)m_data.offset, m_data.user_tag, m_data.ref_count,
                   m_data.shadow_depth, m_data.external_pager,
                   m_data.share_mode, m_data.is_submap, m_data.behavior,
                   m_data.object_id, m_data.user_wired_count);
  }
  m_curr_protection = m_data.protection;

  // We make a request for an address and got no error back, but this
  // doesn't mean that "addr" is in the range. The data in this object will
  // be valid though, so you could see where the next region begins. So we
  // return false, yet leave "m_err" with a successfull return code.
  return !((addr < m_start) || (addr >= (m_start + m_size)));
}

```


## SetProtection

```c++
bool MachVMRegion::SetProtections(mach_vm_address_t addr, mach_vm_size_t size,
                                  vm_prot_t prot) {
  if (ContainsAddress(addr)) {
    mach_vm_size_t prot_size = size;
    mach_vm_address_t end_addr = EndAddress();
    if (prot_size > (end_addr - addr))
      prot_size = end_addr - addr;

    if (prot_size > 0) {
      if (prot == (m_curr_protection & VM_PROT_ALL)) {
        DNBLogThreadedIf(LOG_MEMORY_PROTECTIONS | LOG_VERBOSE,
                         "MachVMRegion::%s: protections (%u) already "
                         "sufficient for task 0x%4.4x at address 0x%8.8llx) ",
                         __FUNCTION__, prot, m_task, (uint64_t)addr);
        // Protections are already set as requested...
        return true;
      } else {
        m_err = ::mach_vm_protect(m_task, addr, prot_size, 0, prot);
        if (DNBLogCheckLogBit(LOG_MEMORY_PROTECTIONS))
          m_err.LogThreaded("::mach_vm_protect ( task = 0x%4.4x, addr = "
                            "0x%8.8llx, size = %llu, set_max = %i, prot = %u )",
                            m_task, (uint64_t)addr, (uint64_t)prot_size, 0,
                            prot);
        if (m_err.Fail()) {
          // Try again with the ability to create a copy on write region
          m_err = ::mach_vm_protect(m_task, addr, prot_size, 0,
                                    prot | VM_PROT_COPY);
          if (DNBLogCheckLogBit(LOG_MEMORY_PROTECTIONS) || m_err.Fail())
            m_err.LogThreaded("::mach_vm_protect ( task = 0x%4.4x, addr = "
                              "0x%8.8llx, size = %llu, set_max = %i, prot = %u "
                              ")",
                              m_task, (uint64_t)addr, (uint64_t)prot_size, 0,
                              prot | VM_PROT_COPY);
        }
        if (m_err.Success()) {
          m_curr_protection = prot;
          m_protection_addr = addr;
          m_protection_size = prot_size;
          return true;
        }
      }
    } else {
      DNBLogThreadedIf(LOG_MEMORY_PROTECTIONS | LOG_VERBOSE,
                       "%s: Zero size for task 0x%4.4x at address 0x%8.8llx) ",
                       __FUNCTION__, m_task, (uint64_t)addr);
    }
  }
  return false;
}
```

## WriteRegion

```c++
nub_size_t MachVMMemory::WriteRegion(task_t task, const nub_addr_t address,
                                     const void *data,
                                     const nub_size_t data_count) {
  if (data == NULL || data_count == 0)
    return 0;

  nub_size_t total_bytes_written = 0;
  nub_addr_t curr_addr = address;
  const uint8_t *curr_data = (const uint8_t *)data;
  while (total_bytes_written < data_count) {
    mach_msg_type_number_t curr_data_count =
        static_cast<mach_msg_type_number_t>(MaxBytesLeftInPage(
            task, curr_addr, data_count - total_bytes_written));
    m_err =
        ::mach_vm_write(task, curr_addr, (pointer_t)curr_data, curr_data_count);
    if (DNBLogCheckLogBit(LOG_MEMORY) || m_err.Fail())
      m_err.LogThreaded("::mach_vm_write ( task = 0x%4.4x, addr = 0x%8.8llx, "
                        "data = %8.8p, dataCnt = %u )",
                        task, (uint64_t)curr_addr, curr_data, curr_data_count);

#if !defined(__i386__) && !defined(__x86_64__)
    vm_machine_attribute_val_t mattr_value = MATTR_VAL_CACHE_FLUSH;

    m_err = ::vm_machine_attribute(task, curr_addr, curr_data_count,
                                   MATTR_CACHE, &mattr_value);
    if (DNBLogCheckLogBit(LOG_MEMORY) || m_err.Fail())
      m_err.LogThreaded("::vm_machine_attribute ( task = 0x%4.4x, addr = "
                        "0x%8.8llx, size = %u, attr = MATTR_CACHE, mattr_value "
                        "=> MATTR_VAL_CACHE_FLUSH )",
                        task, (uint64_t)curr_addr, curr_data_count);
#endif

    if (m_err.Success()) {
      total_bytes_written += curr_data_count;
      curr_addr += curr_data_count;
      curr_data += curr_data_count;
    } else {
      break;
    }
  }
  return total_bytes_written;
}
nub_size_t MachVMMemory::MaxBytesLeftInPage(task_t task, nub_addr_t addr,
                                            nub_size_t count) {
  const nub_size_t page_size = PageSize(task);
  if (page_size > 0) {
    nub_size_t page_offset = (addr % page_size);
    nub_size_t bytes_left_in_page = page_size - page_offset;
    if (count > bytes_left_in_page)
      count = bytes_left_in_page;
  }
  return count;
}
nub_size_t MachVMMemory::PageSize(task_t task) {
  if (m_page_size == kInvalidPageSize) {
#if defined(TASK_VM_INFO) && TASK_VM_INFO >= 22
    if (task != TASK_NULL) {
      kern_return_t kr;
      mach_msg_type_number_t info_count = TASK_VM_INFO_COUNT;
      task_vm_info_data_t vm_info;
      kr = task_info(task, TASK_VM_INFO, (task_info_t)&vm_info, &info_count);
      if (kr == KERN_SUCCESS) {
        DNBLogThreadedIf(
            LOG_TASK,
            "MachVMMemory::PageSize task_info returned page size of 0x%x",
            (int)vm_info.page_size);
        m_page_size = vm_info.page_size;
        return m_page_size;
      } else {
        DNBLogThreadedIf(LOG_TASK, "MachVMMemory::PageSize task_info call "
                                   "failed to get page size, TASK_VM_INFO %d, "
                                   "TASK_VM_INFO_COUNT %d, kern return %d",
                         TASK_VM_INFO, TASK_VM_INFO_COUNT, kr);
      }
    }
#endif
    m_err = ::host_page_size(::mach_host_self(), &m_page_size);
    if (m_err.Fail())
      m_page_size = 0;
  }
  return m_page_size;
}
```

## RestoreProtections

```c++
bool MachVMRegion::RestoreProtections() {
  if (m_curr_protection != m_data.protection && m_protection_size > 0) {
    m_err = ::mach_vm_protect(m_task, m_protection_addr, m_protection_size, 0,
                              m_data.protection);
    if (DNBLogCheckLogBit(LOG_MEMORY_PROTECTIONS) || m_err.Fail())
      m_err.LogThreaded("::mach_vm_protect ( task = 0x%4.4x, addr = 0x%8.8llx, "
                        "size = %llu, set_max = %i, prot = %u )",
                        m_task, (uint64_t)m_protection_addr,
                        (uint64_t)m_protection_size, 0, m_data.protection);
    if (m_err.Success()) {
      m_protection_size = 0;
      m_protection_addr = INVALID_NUB_ADDRESS;
      m_curr_protection = m_data.protection;
      return true;
    }
  } else {
    m_err.Clear();
    return true;
  }

  return false;
}
```